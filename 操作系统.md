

---
- **RSS**（Resident Set Size）：真正加载到物理内存中的那部分。
- **VSZ**（Virtual Set Size）：虚拟地址空间中已被进程使用部分的大小，注意并不是虚拟地址空间
---

# ✅`fork()`
## 🧪 基本使用示例：父进程继续工作，子进程处理子任务

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 子进程：后台打印
        for (int i = 0; i < 5; i++) {
            printf("子进程工作中...\n");
            sleep(1);
        }
    } else if (pid > 0) {
        // 父进程：主任务
        printf("父进程继续执行主流程\n");
        // 可在此不阻塞等待子进程
    }
    return 0;
}
```

👆适合：

* 前台执行主任务，后台 fork 出一个子进程做监控、日志、任务队列处理等。

---
---

## 🧪  `fork()` 的返回值设计语义

```c
pid_t fork(void);
```

* `fork()` 在父进程中返回 **子进程的 pid（大于 0）**；
* `fork()` 在子进程中返回 **0**；
* `fork()` 出错时返回 **-1**（只会在父进程中出错，子进程不会存在）；

### 所以：

| 条件         | 说明           | 代表谁               |
| ---------- | ------------ | ----------------- |
| `pid == 0` | 表示现在是在子进程中执行 | ✅ 子进程             |
| `pid > 0`  | 表示现在是在父进程中执行 | ✅ 父进程             |
| `pid < 0`  | 表示 fork 失败   | ❌ 出错处理（一般加个 else） |

---
---

## 🧪 结论

`fork()` 后的结构建议 **永远用三分式判断**：

```c
if (pid == 0) {
    // 子进程逻辑
} else if (pid > 0) {
    // 父进程逻辑
} else {
    // 错误处理
}
```

这样写的优点：

* ✅ 明确区分三种情况
* ✅ 避免错误被隐藏
* ✅ 逻辑直观，便于调试与维护

---
---

## 🧪 fork 的行为本质

当调用 `fork()` 时，**内核会创建一个新的进程（子进程）**，这个新进程是当前父进程的**几乎完整的复制品**，包括：

| 内容         | 是否复制    | 说明                             |
| ---------- | ------- | ------------------------------ |
| 用户空间内存     | ✅（写时复制） | 虽然复制了，但采用 COW（Copy-on-Write）机制 |
| 寄存器值       | ✅       | 包括 `PC`（程序计数器）、`SP`（栈指针）等      |
| 打开文件描述符表   | ✅       | 父子进程共享文件描述符引用，但各自独立管理          |
| 当前进程执行位置   | ✅       | 所以子进程从 `fork()` 返回处继续执行        |
| PID / PPID | ❌       | 子进程有自己新的 PID，PPID 指向父进程 PID    |
| 信号处理设置等    | ✅       | 复制信号掩码、处理函数等                   |

---
---

## 🧪 Copy-on-Write（写时复制）机制

`fork()` 时看起来复制了父进程的整个内存空间，但实际上为了节省性能，Linux 内核采用了 COW（Copy-On-Write）机制：

* 子进程复制父进程页表，然后父子进程均在几乎每个页表项上**统一打上只读 + COW 标志**（有些地方不需要打上只读 + COW 标志，如记录只读代码段（.text）映射的页表项等）
* 父子共享相同的物理内存页，都是只读映射；
* 一旦父或子有**写入**操作，内核才会分配新的物理页副本（开销在写时才付出）；

这让 `fork()` 非常高效，尤其适合场景是：

```c
if (fork() == 0) {
    // 在子进程里 exec 一个新程序，不需要写原内存
    execl("/bin/ls", "ls", NULL);
}
```

👆这种情况下，fork 之后马上执行 `exec()`，不会写任何内存，**COW 甚至不会触发**，性能非常好。

---
---
## 🧪 总结

fork系统调用是：复制**虚拟地址空间 + 部分内核结构**的快照，用户空间部分采用 COW