# Python 中私有变量和函数的命名规约（PEP 8）

## 🧑‍💻 Python 中私有变量和函数的命名规约（PEP 8）

Python 虽然没有像 Java、C++ 那样的强制访问控制，但**通过命名约定来提示私有性**。

### ✅ 命名约定总结：

|写法|含义|示例|
|---|---|---|
|`_name`|受保护的变量/函数，仅供模块内部或类内部使用|`_helper_func()`|
|`__name`|类内部私有成员，会触发**名称改写（name mangling）**机制|`self.__secret` 变成 `self._ClassName__secret`|
|`__name__`|特殊变量或“魔法方法”|`__init__`、`__str__`、`__name__`|
|`name_`|为避免与关键词冲突时使用|`class_ = MyClass`|

> 🚨 注意：这只是“规矩（convention）”，不是强制语法，Python 并不限制你访问 `_` 或 `__` 开头的变量，它只是建议你别乱用。

---

### 🧪 示例说明：

```python
class MyClass:
    def __init__(self):
        self._internal_value = 42        # 表示“受保护”的变量
        self.__really_private = 'secret' # 表示“类私有”，经过 name mangling

    def _helper(self):                  # 受保护函数
        pass

    def __real_helper(self):           # 真正私有函数（类外难访问）
        pass

print(MyClass().__dict__)
# 输出中 __really_private 实际变为 _MyClass__really_private
```

---

### ✅ 总结建议：

|用法目的|建议命名方式|
|---|---|
|模块内部用、不希望外部调用|`_xxx`（单下划线）|
|类私有成员（防止子类冲突）|`__xxx`（双下划线）|
|避免关键字冲突|`xxx_`（尾部下划线）|
|系统保留魔法方法|`__xxx__`（不要自己随便定义）|

---

### 📌 总结一句话：

> Python 中通过 `_` 和 `__` 前缀来标识变量/函数的“私有”程度，是一种约定俗成的访问控制方式。

# 用importlib库动态加载模块
**Q：此处说的动态加载是什么概念，就是解释器如果判断这个库不用了就会自动清出内存吗，如果不加就从导入开始就一直留在内存吗**
A：
你问的非常好，这触及到 Python 的模块导入、内存管理机制，以及“动态加载”背后的运行时行为。我们逐一来清晰解释。

---

## ✅ 一、什么是“动态加载”模块？

所谓“动态加载”，就是程序**在运行过程中，按需导入模块**，而不是在程序一开始就写死 `import xxx`。

### 🌰 静态导入 vs 动态导入

```python
# 静态导入（写死在文件顶部）
import math
print(math.sqrt(4))

# 动态导入（运行到那一行时才导入）
import importlib
math = importlib.import_module('math')
print(math.sqrt(4))
```

### 🔁 动态加载的意义：

|特点|说明|
|---|---|
|**延迟导入（lazy load）**|只有真正需要的时候才导入|
|**按需切换模块**|模块名可以写成字符串变量，实现插件机制|
|**可运行时替换或重载**|可在运行中重新导入（如 `reload()`）或导入不同实现|
|**适合大型系统/可插拔架构**|不同功能模块互相独立，加载时机可控|

---

## ✅ 二、模块加载后，Python 会自动清出内存吗？

**不会自动清除！**  
Python 的模块一旦被 `import`，就会：

1. **执行一次**模块的代码（构造函数、顶层语句等）；
    
2. 把模块对象**缓存在 `sys.modules` 中**；
    
3. 后续 `import` 同一模块只会直接引用缓存，不会重复执行。
    

### 🧠 内存何时释放？

- 模块对象会一直存在，直到：
    
    - 程序退出（解释器关闭）
        
    - 手动 `del sys.modules['module_name']` + `gc.collect()`，并且没有其他引用
        
- Python 本身**不会“清理不用的模块”**，不像 Java 有类卸载机制。
    

---

## ✅ 三、如果静态导入，是不是模块会一直占内存？

是的，导入后模块对象就存在于 `sys.modules` 中，不会自动释放。区别在于：

|方式|加载时间|内存使用|控制粒度|
|---|---|---|---|
|静态导入|启动时立即加载|占用更早|粗略，不能替换|
|动态导入|运行时加载|更延迟，可控|更灵活，可以卸载重载|

---

## ✅ 四、总结一句话

> “动态加载”是指在程序运行时按需加载模块，便于构建灵活的系统架构；但**无论静态还是动态导入，模块一旦导入，就不会自动从内存中清除，除非你手动清理引用并调用垃圾回收。**

---

如果你感兴趣，我可以给你演示：

- `sys.modules` 查看模块缓存
    
- 手动卸载模块的方式
    
- 比较动态导入 vs 静态导入的内存占用差异
    

要不要继续？